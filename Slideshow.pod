=head1 Chess Inspector

=head2 Visualize Chess Games

=head1 Chess::Inspector

=over

=item 1

It's made of Perl!

=item 2

L<It's on github|https://github.com/ology/Chess-Inspector>
and will run on any machine with Chameleon5 installed.

=item 3

It only depends on two modules:
L<Chess::Rep::Coverage|https://metacpan.org/pod/Chess::Rep::Coverage>
and
L<Chess::Rep|https://metacpan.org/pod/Chess::Rep>.

=back

=head1 Chameleon5

Provides a raw platform, the scaffolding, to display our chessboard and the game
information in a friendly web form.

Not open source available, but not closed source either.

Maintaining a public release would be overly budensome, at this stage of heavy
active development for (mostly) internal purposes.

I would like to get this happening with Mojo next...

=head1 Chess

=begin html

<img src="../site_root/img/chess.jpg" style="float:right; vertical-align:top"/>

=end html

=over

=item It's ancient!

=item It's a classic programming exercise!

=item But what is going on besides shuffling pieces?

=item What is the "potential energy" of the pieces?

=item Can part of the thought process in movement be exposed?

=back

=head1 Mechanical Effort

The heavy lifting comes in three phases:

=over

=item 1

The computation of the coverage of a chessboard ply given acting pieces.

=item 2

Converting this coverage data into displayable elements (hashes!).

=item 3

Rendering these elements for display.

=back

=head1 Chess Coverage

B<What's that you say??>

"Threat, protection and movement over the surface of the chessboard."

=begin text

my $ply = Chess::Rep::Coverage->new;
$ply->set_from_fen($fen);
my $cover = $ply->coverage;

=end

=head1 Prepare To Engage!

Append the computed cell and player states to the request response.

=begin text

$self->fast_append(
    parent => $parent,
    tag    => 'cell',
    data   => {
        row            => $row,
        col            => $col,
        position       => $posn,
        previous       => $prev,
        piece          => $piece,
        protected      => $protect,
        threatened     => $threat,
        white_can_move => $wmove,
        black_can_move => $bmove,
    },
);

=end

=head1 Visualize

Display our chessboard as an HTML table with CSS styling.

My choice of rendering data: XML!

Therefore, I use XSLT (specifically XML::LibXSLT) for the job.

I could very well append JSON and use Javascript to render things.

=head1 The Gory Details

=begin text

<table>
<xsl:for-each select="//response/board">
  <tr>
    <xsl:for-each select="cell">
    <xsl:variable name="colrow"><xsl:value-of select="@col"/><xsl:value-of select="@row"/></xsl:variable>
    <td id="{$colrow}" align="center" height="55" width="55">
      <xsl:if test="//response/game/@to_move > 0">
        <xsl:if test="@black_can_move > 0">
          <xsl:attribute name="style">background: tan</xsl:attribute>
        </xsl:if>
        ...

=end

"Yikes! Run!" I hear you say.  But this is very fast. It actually only looks
scary at first. And it's based on a tried and true industry standard. Also, like
I say, one alternative.

=head1 Show Us Something Already!

=begin html

<img src="../site_root/img/coverage.png" style="float:right; vertical-align:top"/>

=end html

=over

=item Blue - White can move

=item Tan - Black can move

=item Green - Protected

=item Yello - Threatened

=item White - Not threatened

=back

=cut
